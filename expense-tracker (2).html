<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Expense Tracker</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; background: linear-gradient(to bottom right, #f8fafc, #dbeafe); min-height: 100vh; margin: 0; padding: 20px; }
    .container { max-width: 1200px; margin: 0 auto; }
    .btn { padding: 10px 16px; border-radius: 8px; border: none; cursor: pointer; font-size: 14px; font-weight: 500; }
    .btn-blue { background: #3b82f6; color: white; }
    .btn-purple { background: #8b5cf6; color: white; }
    .btn-green { background: #10b981; color: white; }
    .btn-gray { background: #e5e7eb; color: #1f2937; }
    .btn-red { background: #ef4444; color: white; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .card { background: white; border-radius: 12px; padding: 24px; margin-bottom: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    input[type="file"] { display: none; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #f1f5f9; }
    th { font-weight: 500; color: #64748b; }
    select, input { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; }
    .modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); align-items: center; justify-content: center; z-index: 100; }
    .modal.show { display: flex; }
    .modal-box { background: white; padding: 30px; border-radius: 12px; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto; }
    .error-banner { padding: 16px; background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; border-radius: 8px; margin-bottom: 20px; }
    .error-banner h3 { margin: 0 0 8px 0; font-size: 16px; }
    .error-banner p { margin: 0; font-size: 14px; }
    .error-banner button { margin-top: 12px; }
    .warning-row { background: #fef3c7; }
    .input-group { margin-bottom: 16px; }
    .input-group label { display: block; margin-bottom: 6px; font-weight: 500; }
    .input-group input, .input-group select { width: 100%; box-sizing: border-box; }
    .radio-group { display: flex; gap: 16px; margin-bottom: 8px; flex-wrap: wrap; }
    .radio-group label { display: flex; align-items: center; gap: 6px; font-weight: normal; cursor: pointer; }
    .auto-badge { display: inline-block; background: #dbeafe; color: #1e40af; font-size: 10px; padding: 2px 6px; border-radius: 4px; margin-left: 6px; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, Component } = React;

    const CATEGORIES = ['Groceries', 'Rent', 'Utilities', 'Transportation', 'Entertainment', 'Healthcare', 'Shopping', 'Dining', 'Travel', 'Subscriptions', 'Income', 'Transfer', 'Restaurant', 'Other'];

    // Map CSV categories to our categories
    const CATEGORY_MAP = {
      'restaurant': 'Dining',
      'dining': 'Dining',
      'food': 'Dining',
      'transportation': 'Transportation',
      'taxis': 'Transportation',
      'taxi': 'Transportation',
      'coach': 'Transportation',
      'rideshare': 'Transportation',
      'travel': 'Travel',
      'airline': 'Travel',
      'airlines': 'Travel',
      'hotel': 'Travel',
      'lodging': 'Travel',
      'grocery': 'Groceries',
      'groceries': 'Groceries',
      'supermarket': 'Groceries',
      'shopping': 'Shopping',
      'merchandise': 'Shopping',
      'retail': 'Shopping',
      'entertainment': 'Entertainment',
      'recreation': 'Entertainment',
      'health': 'Healthcare',
      'healthcare': 'Healthcare',
      'medical': 'Healthcare',
      'pharmacy': 'Healthcare',
      'utilities': 'Utilities',
      'utility': 'Utilities',
      'subscription': 'Subscriptions',
      'subscriptions': 'Subscriptions',
      'streaming': 'Subscriptions',
      'rent': 'Rent',
      'mortgage': 'Rent',
      'housing': 'Rent',
      'income': 'Income',
      'payment': 'Income',
      'deposit': 'Income',
      'refund': 'Income',
      'transfer': 'Transfer',
      'atm': 'Transfer'
    };

    // Rule-based categorization keywords
    const CATEGORY_RULES = {
      'Groceries': [
        'walmart', 'kroger', 'safeway', 'trader joe', 'whole foods', 'aldi', 'costco', 
        'target', 'publix', 'h-e-b', 'heb', 'wegmans', 'food lion', 'giant', 'stop & shop',
        'shoprite', 'meijer', 'winco', 'sprouts', 'grocery', 'supermarket', 'market basket',
        'albertsons', 'vons', 'ralphs', 'harris teeter', 'winn-dixie', 'food 4 less'
      ],
      'Dining': [
        'sweetgreen', 'mcdonald', 'starbucks', 'chipotle', 'subway', 'burger king', 'wendy',
        'taco bell', 'chick-fil-a', 'dunkin', 'panera', 'domino', 'pizza hut', 'papa john',
        'kfc', 'popeyes', 'sonic', 'five guys', 'in-n-out', 'shake shack', 'chili',
        'applebee', 'olive garden', 'red lobster', 'outback', 'cheesecake factory',
        'ihop', 'denny', 'waffle house', 'buffalo wild', 'wingstop', 'panda express',
        'restaurant', 'cafe', 'coffee', 'diner', 'grill', 'kitchen', 'bistro', 'eatery',
        'doordash', 'uber eats', 'ubereats', 'grubhub', 'postmates', 'seamless', 'caviar',
        'noodles', 'sushi', 'thai', 'chinese', 'mexican', 'italian', 'indian', 'pizza',
        'burger', 'sandwich', 'salad', 'bakery', 'bagel', 'deli'
      ],
      'Transportation': [
        'uber', 'lyft', 'taxi', 'cab', 'shell', 'exxon', 'mobil', 'chevron', 'bp', 'gas',
        'citgo', 'sunoco', 'marathon', 'speedway', 'wawa', 'sheetz', 'quiktrip', 'racetrac',
        'phillips 66', 'valero', 'arco', 'fuel', 'petro', 'parking', 'garage',
        'metro', 'transit', 'bus', 'train', 'amtrak', 'greyhound', 'toll',
        'ez pass', 'fastrak', 'car wash', 'jiffy lube', 'autozone', 'advance auto',
        'pep boys', 'firestone', 'goodyear', 'discount tire', 'tire', 'mechanic'
      ],
      'Shopping': [
        'amazon', 'ebay', 'etsy', 'best buy', 'apple store', 'apple.com', 'microsoft',
        'home depot', 'lowes', 'ikea', 'bed bath', 'pottery barn', 'wayfair', 'overstock',
        'nordstrom', 'macys', 'jcpenney', 'kohls', 'ross', 'tj maxx', 'marshalls',
        'old navy', 'gap', 'banana republic', 'h&m', 'zara', 'forever 21', 'urban outfitters',
        'nike', 'adidas', 'foot locker', 'rei', 'sephora', 'ulta', 'bath & body',
        'office depot', 'staples', 'michaels', 'hobby lobby', 'gamestop', 'mall'
      ],
      'Entertainment': [
        'netflix', 'hulu', 'disney', 'hbo', 'paramount', 'peacock', 'apple tv',
        'spotify', 'apple music', 'pandora', 'audible', 'amc theatre', 'regal', 'cinemark',
        'movie', 'cinema', 'theater', 'xbox', 'playstation', 'nintendo', 'steam',
        'ticketmaster', 'stubhub', 'concert', 'event', 'bowling', 'arcade', 'dave & buster',
        'topgolf', 'golf', 'gym', 'fitness', 'planet fitness', 'la fitness', 'equinox', 'yoga'
      ],
      'Utilities': [
        'electric', 'power', 'energy', 'water bill', 'sewage', 'trash', 'waste management',
        'comcast', 'xfinity', 'spectrum', 'at&t', 'att', 'verizon', 't-mobile', 'tmobile',
        'sprint', 'cricket', 'internet', 'cable', 'phone bill', 'wireless', 'utility'
      ],
      'Healthcare': [
        'pharmacy', 'cvs', 'walgreens', 'rite aid', 'drugstore', 'doctor', 'hospital',
        'clinic', 'medical', 'dental', 'dentist', 'optometrist', 'vision', 'urgent care',
        'health', 'prescription', 'labcorp', 'quest diagnostics', 'therapy', 'therapist'
      ],
      'Travel': [
        'airline', 'delta', 'united', 'american airlines', 'southwest', 'jetblue',
        'spirit', 'frontier', 'alaska air', 'flight', 'airbnb', 'vrbo',
        'hotel', 'marriott', 'hilton', 'hyatt', 'ihg', 'wyndham', 'best western',
        'holiday inn', 'hampton', 'sheraton', 'motel', 'resort', 'inn',
        'expedia', 'booking.com', 'hotels.com', 'kayak', 'priceline',
        'hertz', 'enterprise', 'avis', 'budget', 'car rental', 'cruise', 'carnival'
      ],
      'Subscriptions': [
        'subscription', 'membership', 'monthly', 'annual', 'renewal',
        'adobe', 'microsoft 365', 'office 365', 'dropbox', 'google storage', 'icloud',
        'linkedin', 'premium', 'patreon', 'substack', 'newspaper', 'magazine', 'nytimes'
      ],
      'Income': [
        'payroll', 'salary', 'direct deposit', 'paycheck', 'wages', 'dividend', 'interest',
        'refund', 'reimbursement', 'cashback', 'autopay payment', 'payment - thank you'
      ],
      'Transfer': [
        'transfer', 'ach', 'wire', 'zelle', 'venmo', 'paypal', 'cash app',
        'bank transfer', 'withdrawal', 'atm'
      ]
    };

    // Parse category from CSV (handles formats like "Restaurant-Restaurant" or "Transportation-Taxis & Coach")
    function parseCSVCategory(csvCategory) {
      if (!csvCategory || typeof csvCategory !== 'string') return null;
      
      const cat = csvCategory.trim().toLowerCase();
      if (!cat) return null;
      
      // Try direct match first
      if (CATEGORY_MAP[cat]) return CATEGORY_MAP[cat];
      
      // Split on dash and try each part
      const parts = cat.split('-').map(p => p.trim());
      for (const part of parts) {
        if (CATEGORY_MAP[part]) return CATEGORY_MAP[part];
        
        // Try partial matches
        for (const [key, value] of Object.entries(CATEGORY_MAP)) {
          if (part.includes(key) || key.includes(part)) {
            return value;
          }
        }
      }
      
      // Try matching against our category list directly
      for (const category of CATEGORIES) {
        if (cat.includes(category.toLowerCase())) {
          return category;
        }
      }
      
      return null;
    }

    // Auto-categorize based on description
    function autoCategorize(description) {
      if (!description) return { category: 'Uncategorized', auto: false };
      
      const desc = description.toLowerCase();
      
      for (const [category, keywords] of Object.entries(CATEGORY_RULES)) {
        for (const keyword of keywords) {
          if (desc.includes(keyword.toLowerCase())) {
            return { category, auto: true };
          }
        }
      }
      
      return { category: 'Uncategorized', auto: false };
    }

    // Error Boundary
    class ErrorBoundary extends Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('App Error:', error, errorInfo);
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="container">
              <div className="error-banner">
                <h3>‚ö†Ô∏è Something went wrong</h3>
                <p>The app encountered an error. This might be due to corrupted data.</p>
                <p style={{marginTop: '8px', fontSize: '12px', fontFamily: 'monospace', color: '#666'}}>
                  {this.state.error?.message}
                </p>
                <button 
                  className="btn btn-red" 
                  onClick={() => {
                    localStorage.removeItem('expenses');
                    window.location.reload();
                  }}
                >
                  Clear Data & Reload
                </button>
                <button 
                  className="btn btn-gray" 
                  style={{marginLeft: '10px'}}
                  onClick={() => window.location.reload()}
                >
                  Try Again
                </button>
              </div>
            </div>
          );
        }

        return this.props.children;
      }
    }

    function safeAmount(value) {
      if (value === null || value === undefined || isNaN(value)) return 0;
      return Number(value);
    }

    function formatAmount(value) {
      const num = safeAmount(value);
      return '$' + num.toFixed(2);
    }

    function validateExpense(exp, index) {
      if (!exp || typeof exp !== 'object') {
        return { valid: false, expense: null, errors: ['Invalid expense data'] };
      }

      const cleaned = {
        id: exp.id || Date.now() + index,
        date: exp.date || 'Unknown',
        amount: safeAmount(exp.amount),
        category: exp.category || 'Uncategorized',
        account: exp.account || 'Unknown',
        description: exp.description || '',
        autoCategorized: exp.autoCategorized || false,
        hasError: false,
        errorMsg: null
      };

      if (exp.amount === null || exp.amount === undefined || isNaN(exp.amount)) {
        cleaned.hasError = true;
        cleaned.errorMsg = 'Invalid amount';
      }

      return { valid: true, expense: cleaned, errors: [] };
    }

    function loadExpenses() {
      try {
        const saved = localStorage.getItem('expenses');
        if (!saved) return { expenses: [], errors: [] };

        const parsed = JSON.parse(saved);
        if (!Array.isArray(parsed)) {
          return { expenses: [], errors: ['Stored data is not an array.'] };
        }

        const results = parsed.map((exp, i) => validateExpense(exp, i));
        const validExpenses = results.filter(r => r.valid && r.expense).map(r => r.expense);
        const errorCount = results.filter(r => r.expense?.hasError).length;
        const errors = errorCount > 0 ? [`${errorCount} expense(s) had issues`] : [];

        return { expenses: validExpenses, errors };
      } catch (e) {
        console.error('Error loading from localStorage:', e);
        return { expenses: [], errors: [`Failed to load saved data: ${e.message}`] };
      }
    }
    
    function App() {
      const [expenses, setExpenses] = useState([]);
      const [loadErrors, setLoadErrors] = useState([]);
      const [importErrors, setImportErrors] = useState([]);
      const [showModal, setShowModal] = useState(false);
      const [csvHeaders, setCsvHeaders] = useState([]);
      const [csvData, setCsvData] = useState([]);
      const [mapping, setMapping] = useState({ date: '', amount: '', description: '', account: '', category: '' });
      const [accountMode, setAccountMode] = useState('manual');
      const [manualAccountName, setManualAccountName] = useState('');
      const [categoryMode, setCategoryMode] = useState('auto');
      const [message, setMessage] = useState('');

      useEffect(() => {
        const { expenses: loaded, errors } = loadExpenses();
        setExpenses(loaded);
        setLoadErrors(errors);
      }, []);

      useEffect(() => {
        try {
          localStorage.setItem('expenses', JSON.stringify(expenses));
        } catch (e) {
          console.error('Error saving to localStorage:', e);
        }
      }, [expenses]);

      function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        setImportErrors([]);
        
        // Use PapaParse for proper CSV parsing (handles quotes, newlines, etc.)
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            if (results.errors.length > 0) {
              setImportErrors(results.errors.map(e => e.message));
            }
            
            if (results.data.length === 0) {
              setImportErrors(['File is empty or could not be parsed']);
              return;
            }
            
            const headers = results.meta.fields || [];
            setCsvHeaders(headers);
            setCsvData(results.data);
            setMapping({ date: '', amount: '', description: '', account: '', category: '' });
            setAccountMode('manual');
            setCategoryMode('auto');
            setManualAccountName('');
            setShowModal(true);
          },
          error: function(error) {
            setImportErrors([`Failed to parse CSV: ${error.message}`]);
          }
        });
        
        e.target.value = '';
      }

      function processImport() {
        if (!mapping.date || !mapping.amount) {
          alert('Please select Date and Amount columns');
          return;
        }

        let accountName = 'Imported';
        if (accountMode === 'manual' && manualAccountName.trim()) {
          accountName = manualAccountName.trim();
        }

        const errors = [];
        let skippedCount = 0;
        let autoCategorizedCount = 0;
        let csvCategorizedCount = 0;

        const newExpenses = csvData.map((row, i) => {
          try {
            const dateStr = row[mapping.date];
            const dateObj = new Date(dateStr);
            const date = !isNaN(dateObj.getTime()) ? dateObj.toISOString().slice(0, 10) : new Date().toISOString().slice(0, 10);
            
            const rawAmountStr = String(row[mapping.amount] || '0').replace(/[$,]/g, '');
            const rawAmount = parseFloat(rawAmountStr);
            const amount = isNaN(rawAmount) ? 0 : Math.abs(rawAmount);
            
            if (amount === 0) {
              skippedCount++;
              return null;
            }

            const finalAccount = accountMode === 'column' && mapping.account 
              ? (row[mapping.account] || accountName)
              : accountName;

            const description = mapping.description ? row[mapping.description] : '';

            // Determine category
            let category = 'Uncategorized';
            let autoCategorized = false;

            // First, try CSV column if selected
            if (categoryMode === 'column' && mapping.category) {
              const csvCategory = row[mapping.category];
              const mapped = parseCSVCategory(csvCategory);
              if (mapped) {
                category = mapped;
                csvCategorizedCount++;
              }
            }

            // If still uncategorized and auto mode enabled, try rule-based
            if (category === 'Uncategorized' && (categoryMode === 'auto' || categoryMode === 'column')) {
              const result = autoCategorize(description);
              if (result.auto) {
                category = result.category;
                autoCategorized = true;
                autoCategorizedCount++;
              }
            }
            
            return {
              id: Date.now() + Math.random() * 1000000 + i,
              date,
              amount,
              category,
              account: finalAccount,
              description,
              autoCategorized,
              hasError: false,
              errorMsg: null
            };
          } catch (err) {
            errors.push(`Row ${i + 1}: ${err.message}`);
            return null;
          }
        }).filter(e => e !== null);

        if (skippedCount > 0) {
          errors.push(`${skippedCount} row(s) skipped due to zero or invalid amounts`);
        }

        setExpenses([...expenses, ...newExpenses]);
        
        if (errors.length > 0) {
          setImportErrors(errors);
        }

        let msg = `Imported ${newExpenses.length} transactions`;
        if (csvCategorizedCount > 0) {
          msg += ` (${csvCategorizedCount} from CSV`;
          if (autoCategorizedCount > 0) {
            msg += `, ${autoCategorizedCount} auto-detected`;
          }
          msg += ')';
        } else if (autoCategorizedCount > 0) {
          msg += ` (${autoCategorizedCount} auto-categorized)`;
        }
        
        setMessage(msg);
        setTimeout(() => setMessage(''), 5000);
        setShowModal(false);
        setCsvHeaders([]);
        setCsvData([]);
        setMapping({ date: '', amount: '', description: '', account: '', category: '' });
        setManualAccountName('');
      }

      function recategorizeUncategorized() {
        let count = 0;
        const updated = expenses.map(exp => {
          if (exp.category === 'Uncategorized') {
            const result = autoCategorize(exp.description);
            if (result.auto) {
              count++;
              return { ...exp, category: result.category, autoCategorized: true };
            }
          }
          return exp;
        });
        
        setExpenses(updated);
        setMessage(`Auto-categorized ${count} transactions`);
        setTimeout(() => setMessage(''), 3000);
      }

      function updateCategory(id, cat) {
        setExpenses(expenses.map(e => e.id === id ? {...e, category: cat, autoCategorized: false} : e));
      }

      function deleteExpense(id) {
        setExpenses(expenses.filter(e => e.id !== id));
      }

      function removeErrorExpenses() {
        setExpenses(expenses.filter(e => !e.hasError));
      }

      function clearAllData() {
        if (confirm('Are you sure you want to delete all expenses? This cannot be undone.')) {
          setExpenses([]);
          setLoadErrors([]);
          setImportErrors([]);
          localStorage.removeItem('expenses');
        }
      }

      function dismissErrors(type) {
        if (type === 'load') setLoadErrors([]);
        if (type === 'import') setImportErrors([]);
      }

      function exportCSV() {
        const csv = ['date,amount,category,account,description', ...expenses.map(e => 
          `${e.date},${safeAmount(e.amount)},${e.category},${e.account},"${(e.description || '').replace(/"/g, '""')}"`
        )].join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'expenses.csv';
        a.click();
        URL.revokeObjectURL(url);
      }

      const validExpenses = expenses.filter(e => !e.hasError);
      const errorExpenses = expenses.filter(e => e.hasError);
      const categorized = validExpenses.filter(e => e.category !== 'Uncategorized');
      const total = categorized.reduce((sum, e) => sum + safeAmount(e.amount), 0);
      const uncategorizedCount = validExpenses.length - categorized.length;

      return (
        <div className="container">
          <div style={{marginBottom: '30px'}}>
            <h1 style={{fontSize: '32px', fontWeight: 'bold', marginBottom: '8px'}}>Expense Tracker</h1>
            <p style={{color: '#64748b'}}>Import bank CSVs and categorize expenses</p>
          </div>

          {loadErrors.length > 0 && (
            <div className="error-banner">
              <h3>‚ö†Ô∏è Data Loading Issues</h3>
              {loadErrors.map((err, i) => <p key={i}>{err}</p>)}
              <button className="btn btn-gray" onClick={() => dismissErrors('load')}>Dismiss</button>
            </div>
          )}

          {importErrors.length > 0 && (
            <div className="error-banner">
              <h3>‚ö†Ô∏è Import Issues</h3>
              {importErrors.slice(0, 5).map((err, i) => <p key={i}>{err}</p>)}
              {importErrors.length > 5 && <p>...and {importErrors.length - 5} more issues</p>}
              <button className="btn btn-gray" onClick={() => dismissErrors('import')}>Dismiss</button>
            </div>
          )}

          {errorExpenses.length > 0 && (
            <div className="error-banner">
              <h3>‚ö†Ô∏è {errorExpenses.length} expense(s) have data issues</h3>
              <p>These rows are highlighted in yellow below.</p>
              <button className="btn btn-red" onClick={removeErrorExpenses}>Remove All Problem Rows</button>
            </div>
          )}

          <div style={{display: 'flex', gap: '10px', marginBottom: '20px', flexWrap: 'wrap'}}>
            <label className="btn btn-blue">
              üì§ Import CSV
              <input type="file" accept=".csv" onChange={handleFileUpload} />
            </label>
            <button className="btn btn-purple" onClick={exportCSV}>üì• Export</button>
            {uncategorizedCount > 0 && (
              <button className="btn btn-green" onClick={recategorizeUncategorized}>
                üè∑Ô∏è Auto-Categorize ({uncategorizedCount})
              </button>
            )}
            <button className="btn btn-red" onClick={clearAllData}>üóëÔ∏è Clear All</button>
          </div>

          {message && (
            <div style={{padding: '12px', background: '#dbeafe', color: '#1e40af', borderRadius: '8px', marginBottom: '20px'}}>
              {message}
            </div>
          )}

          {uncategorizedCount > 0 && (
            <div style={{padding: '12px', background: '#fef3c7', color: '#92400e', borderRadius: '8px', marginBottom: '20px'}}>
              ‚ö†Ô∏è {uncategorizedCount} transactions need categorization
            </div>
          )}

          <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '20px', marginBottom: '30px'}}>
            <div className="card">
              <div style={{fontSize: '14px', color: '#64748b', marginBottom: '4px'}}>Total</div>
              <div style={{fontSize: '28px', fontWeight: 'bold'}}>{formatAmount(total)}</div>
            </div>
            <div className="card">
              <div style={{fontSize: '14px', color: '#64748b', marginBottom: '4px'}}>Categorized</div>
              <div style={{fontSize: '28px', fontWeight: 'bold'}}>{categorized.length}</div>
            </div>
            <div className="card">
              <div style={{fontSize: '14px', color: '#64748b', marginBottom: '4px'}}>To Review</div>
              <div style={{fontSize: '28px', fontWeight: 'bold'}}>{uncategorizedCount}</div>
            </div>
          </div>

          <div className="card">
            <h2 style={{fontSize: '20px', fontWeight: '600', marginBottom: '20px'}}>Transactions</h2>
            <div style={{overflowX: 'auto'}}>
              <table>
                <thead>
                  <tr>
                    <th>Date</th>
                    <th>Description</th>
                    <th>Account</th>
                    <th>Category</th>
                    <th style={{textAlign: 'right'}}>Amount</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody>
                  {expenses.length === 0 ? (
                    <tr>
                      <td colSpan="6" style={{textAlign: 'center', color: '#64748b', padding: '40px'}}>
                        No expenses yet. Import a CSV to get started.
                      </td>
                    </tr>
                  ) : (
                    [...expenses].sort((a, b) => {
                      if (a.hasError && !b.hasError) return -1;
                      if (!a.hasError && b.hasError) return 1;
                      if (a.category === 'Uncategorized' && b.category !== 'Uncategorized') return -1;
                      if (a.category !== 'Uncategorized' && b.category === 'Uncategorized') return 1;
                      return new Date(b.date) - new Date(a.date);
                    }).map(exp => (
                      <tr key={exp.id} className={exp.hasError ? 'warning-row' : ''}>
                        <td>
                          {exp.date}
                          {exp.hasError && (
                            <div style={{fontSize: '11px', color: '#991b1b'}}>‚ö†Ô∏è {exp.errorMsg}</div>
                          )}
                        </td>
                        <td style={{maxWidth: '250px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap'}}>
                          {exp.description}
                        </td>
                        <td>{exp.account}</td>
                        <td>
                          <select 
                            value={exp.category} 
                            onChange={(e) => updateCategory(exp.id, e.target.value)}
                            style={{
                              background: exp.category === 'Uncategorized' ? '#fee2e2' : '#dbeafe',
                              color: exp.category === 'Uncategorized' ? '#991b1b' : '#1e40af',
                              border: 'none',
                              padding: '4px 8px',
                              borderRadius: '12px',
                              cursor: 'pointer'
                            }}
                          >
                            <option value="Uncategorized">Uncategorized</option>
                            {CATEGORIES.map(c => <option key={c} value={c}>{c}</option>)}
                          </select>
                          {exp.autoCategorized && <span className="auto-badge">Auto</span>}
                        </td>
                        <td style={{textAlign: 'right', fontWeight: '600'}}>{formatAmount(exp.amount)}</td>
                        <td>
                          <button onClick={() => deleteExpense(exp.id)} style={{background: 'none', border: 'none', cursor: 'pointer', fontSize: '18px'}}>
                            üóëÔ∏è
                          </button>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </div>

          <div className={`modal ${showModal ? 'show' : ''}`}>
            <div className="modal-box">
              <h2 style={{fontSize: '22px', fontWeight: 'bold', marginBottom: '16px'}}>Map CSV Columns</h2>
              <p style={{color: '#64748b', marginBottom: '20px'}}>Match columns (Date & Amount required)</p>
              
              <div className="input-group">
                <label>Date *</label>
                <select value={mapping.date} onChange={(e) => setMapping({...mapping, date: e.target.value})}>
                  <option value="">Select...</option>
                  {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                </select>
              </div>

              <div className="input-group">
                <label>Amount *</label>
                <select value={mapping.amount} onChange={(e) => setMapping({...mapping, amount: e.target.value})}>
                  <option value="">Select...</option>
                  {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                </select>
              </div>

              <div className="input-group">
                <label>Description</label>
                <select value={mapping.description} onChange={(e) => setMapping({...mapping, description: e.target.value})}>
                  <option value="">Select...</option>
                  {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                </select>
              </div>

              <div className="input-group">
                <label>Account</label>
                <div className="radio-group">
                  <label>
                    <input 
                      type="radio" 
                      name="accountMode" 
                      checked={accountMode === 'manual'} 
                      onChange={() => setAccountMode('manual')}
                    />
                    Enter name
                  </label>
                  <label>
                    <input 
                      type="radio" 
                      name="accountMode" 
                      checked={accountMode === 'column'} 
                      onChange={() => setAccountMode('column')}
                    />
                    From CSV
                  </label>
                </div>
                
                {accountMode === 'manual' ? (
                  <input 
                    type="text" 
                    placeholder="e.g., Chase Checking, Amex Gold..." 
                    value={manualAccountName}
                    onChange={(e) => setManualAccountName(e.target.value)}
                  />
                ) : (
                  <select value={mapping.account} onChange={(e) => setMapping({...mapping, account: e.target.value})}>
                    <option value="">Select...</option>
                    {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                  </select>
                )}
              </div>

              <div className="input-group">
                <label>Category</label>
                <div className="radio-group">
                  <label>
                    <input 
                      type="radio" 
                      name="categoryMode" 
                      checked={categoryMode === 'auto'} 
                      onChange={() => setCategoryMode('auto')}
                    />
                    üè∑Ô∏è Rule-based
                  </label>
                  <label>
                    <input 
                      type="radio" 
                      name="categoryMode" 
                      checked={categoryMode === 'column'} 
                      onChange={() => setCategoryMode('column')}
                    />
                    From CSV
                  </label>
                  <label>
                    <input 
                      type="radio" 
                      name="categoryMode" 
                      checked={categoryMode === 'none'} 
                      onChange={() => setCategoryMode('none')}
                    />
                    Manual
                  </label>
                </div>
                <p style={{fontSize: '12px', color: '#64748b', marginBottom: '8px'}}>
                  {categoryMode === 'auto' && 'Detects category from description (e.g., "Sweetgreen" ‚Üí Dining)'}
                  {categoryMode === 'column' && 'Uses CSV column + rule-based for missing'}
                  {categoryMode === 'none' && 'All imported as Uncategorized'}
                </p>
                
                {categoryMode === 'column' && (
                  <select value={mapping.category} onChange={(e) => setMapping({...mapping, category: e.target.value})}>
                    <option value="">Select...</option>
                    {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                  </select>
                )}
              </div>

              <div style={{display: 'flex', gap: '10px', marginTop: '20px'}}>
                <button onClick={processImport} className="btn btn-blue" style={{flex: 1}}>
                  Import {csvData.length} Transactions
                </button>
                <button onClick={() => setShowModal(false)} className="btn btn-gray">Cancel</button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <ErrorBoundary>
        <App />
      </ErrorBoundary>
    );
  </script>
</body>
</html>
