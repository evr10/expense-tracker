<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Expense Tracker</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; background: linear-gradient(to bottom right, #f8fafc, #dbeafe); min-height: 100vh; margin: 0; padding: 20px; }
    .container { max-width: 1200px; margin: 0 auto; }
    .btn { padding: 10px 16px; border-radius: 8px; border: none; cursor: pointer; font-size: 14px; font-weight: 500; }
    .btn-blue { background: #3b82f6; color: white; }
    .btn-purple { background: #8b5cf6; color: white; }
    .btn-green { background: #10b981; color: white; }
    .btn-gray { background: #e5e7eb; color: #1f2937; }
    .btn-red { background: #ef4444; color: white; }
    .card { background: white; border-radius: 12px; padding: 24px; margin-bottom: 20px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    input[type="file"] { display: none; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #f1f5f9; }
    th { font-weight: 500; color: #64748b; }
    select, input { padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; }
    .modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); align-items: center; justify-content: center; }
    .modal.show { display: flex; }
    .modal-box { background: white; padding: 30px; border-radius: 12px; max-width: 500px; width: 90%; }
    .error-banner { padding: 16px; background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; border-radius: 8px; margin-bottom: 20px; }
    .error-banner h3 { margin: 0 0 8px 0; font-size: 16px; }
    .error-banner p { margin: 0; font-size: 14px; }
    .error-banner button { margin-top: 12px; }
    .warning-row { background: #fef3c7; }
    .input-group { margin-bottom: 16px; }
    .input-group label { display: block; margin-bottom: 6px; font-weight: 500; }
    .input-group input, .input-group select { width: 100%; box-sizing: border-box; }
    .radio-group { display: flex; gap: 16px; margin-bottom: 8px; }
    .radio-group label { display: flex; align-items: center; gap: 6px; font-weight: normal; cursor: pointer; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, Component } = React;

    // Error Boundary to catch rendering errors
    class ErrorBoundary extends Component {
      constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
      }

      static getDerivedStateFromError(error) {
        return { hasError: true, error };
      }

      componentDidCatch(error, errorInfo) {
        console.error('App Error:', error, errorInfo);
      }

      render() {
        if (this.state.hasError) {
          return (
            <div className="container">
              <div className="error-banner">
                <h3>‚ö†Ô∏è Something went wrong</h3>
                <p>The app encountered an error. This might be due to corrupted data.</p>
                <p style={{marginTop: '8px', fontSize: '12px', fontFamily: 'monospace', color: '#666'}}>
                  {this.state.error?.message}
                </p>
                <button 
                  className="btn btn-red" 
                  onClick={() => {
                    localStorage.removeItem('expenses');
                    window.location.reload();
                  }}
                >
                  Clear Data & Reload
                </button>
                <button 
                  className="btn btn-gray" 
                  style={{marginLeft: '10px'}}
                  onClick={() => window.location.reload()}
                >
                  Try Again
                </button>
              </div>
            </div>
          );
        }

        return this.props.children;
      }
    }

    // Safe number formatting
    function safeAmount(value) {
      if (value === null || value === undefined || isNaN(value)) {
        return 0;
      }
      return Number(value);
    }

    function formatAmount(value) {
      const num = safeAmount(value);
      return '$' + num.toFixed(2);
    }

    // Validate and clean expense object
    function validateExpense(exp, index) {
      const errors = [];
      
      if (!exp || typeof exp !== 'object') {
        return { valid: false, expense: null, errors: ['Invalid expense data'] };
      }

      const cleaned = {
        id: exp.id || Date.now() + index,
        date: exp.date || 'Unknown',
        amount: safeAmount(exp.amount),
        category: exp.category || 'Uncategorized',
        account: exp.account || 'Unknown',
        description: exp.description || '',
        hasError: false,
        errorMsg: null
      };

      // Check for issues
      if (exp.amount === null || exp.amount === undefined || isNaN(exp.amount)) {
        errors.push('Invalid amount');
        cleaned.hasError = true;
      }

      if (cleaned.amount === 0 && exp.amount !== 0) {
        errors.push('Amount could not be parsed');
        cleaned.hasError = true;
      }

      if (errors.length > 0) {
        cleaned.errorMsg = errors.join(', ');
      }

      return { valid: true, expense: cleaned, errors };
    }

    // Load expenses safely from localStorage
    function loadExpenses() {
      try {
        const saved = localStorage.getItem('expenses');
        if (!saved) return { expenses: [], errors: [] };

        const parsed = JSON.parse(saved);
        if (!Array.isArray(parsed)) {
          return { 
            expenses: [], 
            errors: ['Stored data is not an array. Data has been reset.'] 
          };
        }

        const results = parsed.map((exp, i) => validateExpense(exp, i));
        const validExpenses = results
          .filter(r => r.valid && r.expense)
          .map(r => r.expense);
        
        const errorCount = results.filter(r => r.expense?.hasError).length;
        const errors = errorCount > 0 
          ? [`${errorCount} expense(s) had issues and were loaded with default values`]
          : [];

        return { expenses: validExpenses, errors };
      } catch (e) {
        console.error('Error loading from localStorage:', e);
        return { 
          expenses: [], 
          errors: [`Failed to load saved data: ${e.message}`] 
        };
      }
    }
    
    function App() {
      const [expenses, setExpenses] = useState([]);
      const [loadErrors, setLoadErrors] = useState([]);
      const [importErrors, setImportErrors] = useState([]);
      const [showModal, setShowModal] = useState(false);
      const [csvHeaders, setCsvHeaders] = useState([]);
      const [csvData, setCsvData] = useState([]);
      const [mapping, setMapping] = useState({ date: '', amount: '', description: '', account: '' });
      const [accountMode, setAccountMode] = useState('manual'); // 'manual' or 'column'
      const [manualAccountName, setManualAccountName] = useState('');
      const [message, setMessage] = useState('');

      // Load on mount
      useEffect(() => {
        const { expenses: loaded, errors } = loadExpenses();
        setExpenses(loaded);
        setLoadErrors(errors);
      }, []);

      // Save whenever expenses change
      useEffect(() => {
        try {
          localStorage.setItem('expenses', JSON.stringify(expenses));
        } catch (e) {
          console.error('Error saving to localStorage:', e);
        }
      }, [expenses]);

      const categories = ['Groceries', 'Rent', 'Utilities', 'Transportation', 'Entertainment', 'Healthcare', 'Shopping', 'Dining', 'Other'];

      function handleFileUpload(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        setImportErrors([]);
        
        const reader = new FileReader();
        reader.onerror = () => {
          setImportErrors([`Failed to read file: ${file.name}`]);
        };
        reader.onload = (event) => {
          try {
            const text = event.target.result;
            const lines = text.split('\n').filter(l => l.trim());
            
            if (lines.length === 0) {
              setImportErrors(['File is empty']);
              return;
            }
            
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            
            if (headers.length === 0) {
              setImportErrors(['Could not parse CSV headers']);
              return;
            }
            
            const data = lines.slice(1).map(line => {
              const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
              const row = {};
              headers.forEach((h, i) => row[h] = values[i] || '');
              return row;
            });
            
            setCsvHeaders(headers);
            setCsvData(data);
            // Reset modal state
            setMapping({ date: '', amount: '', description: '', account: '' });
            setAccountMode('manual');
            setManualAccountName('');
            setShowModal(true);
          } catch (err) {
            setImportErrors([`Error parsing CSV: ${err.message}`]);
          }
        };
        reader.readAsText(file);
        e.target.value = '';
      }

      function processImport() {
        if (!mapping.date || !mapping.amount) {
          alert('Please select Date and Amount columns');
          return;
        }

        // Determine account name
        let accountName = 'Imported';
        if (accountMode === 'manual' && manualAccountName.trim()) {
          accountName = manualAccountName.trim();
        }

        const errors = [];
        let skippedCount = 0;

        const newExpenses = csvData.map((row, i) => {
          try {
            const dateStr = row[mapping.date];
            const dateObj = new Date(dateStr);
            const date = !isNaN(dateObj.getTime()) ? dateObj.toISOString().slice(0, 7) : new Date().toISOString().slice(0, 7);
            
            const rawAmountStr = String(row[mapping.amount] || '0').replace(/[$,]/g, '');
            const rawAmount = parseFloat(rawAmountStr);
            const amount = isNaN(rawAmount) ? 0 : Math.abs(rawAmount);
            
            if (amount === 0) {
              skippedCount++;
              return null;
            }

            // Use column value if that mode is selected, otherwise use manual name
            const finalAccount = accountMode === 'column' && mapping.account 
              ? (row[mapping.account] || accountName)
              : accountName;
            
            return {
              id: Date.now() + i,
              date,
              amount,
              category: 'Uncategorized',
              account: finalAccount,
              description: mapping.description ? row[mapping.description] : '',
              hasError: false,
              errorMsg: null
            };
          } catch (err) {
            errors.push(`Row ${i + 1}: ${err.message}`);
            return null;
          }
        }).filter(e => e !== null);

        if (skippedCount > 0) {
          errors.push(`${skippedCount} row(s) skipped due to zero or invalid amounts`);
        }

        setExpenses([...expenses, ...newExpenses]);
        
        if (errors.length > 0) {
          setImportErrors(errors);
        }
        
        setMessage(`Imported ${newExpenses.length} transactions`);
        setTimeout(() => setMessage(''), 3000);
        setShowModal(false);
        setCsvHeaders([]);
        setCsvData([]);
        setMapping({ date: '', amount: '', description: '', account: '' });
        setManualAccountName('');
      }

      function updateCategory(id, cat) {
        setExpenses(expenses.map(e => e.id === id ? {...e, category: cat} : e));
      }

      function deleteExpense(id) {
        setExpenses(expenses.filter(e => e.id !== id));
      }

      function removeErrorExpenses() {
        setExpenses(expenses.filter(e => !e.hasError));
      }

      function clearAllData() {
        if (confirm('Are you sure you want to delete all expenses? This cannot be undone.')) {
          setExpenses([]);
          setLoadErrors([]);
          setImportErrors([]);
          localStorage.removeItem('expenses');
        }
      }

      function dismissErrors(type) {
        if (type === 'load') setLoadErrors([]);
        if (type === 'import') setImportErrors([]);
      }

      function exportCSV() {
        const csv = ['date,amount,category,account,description', ...expenses.map(e => 
          `${e.date},${safeAmount(e.amount)},${e.category},${e.account},"${(e.description || '').replace(/"/g, '""')}"`
        )].join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'expenses.csv';
        a.click();
        URL.revokeObjectURL(url);
      }

      const validExpenses = expenses.filter(e => !e.hasError);
      const errorExpenses = expenses.filter(e => e.hasError);
      const categorized = validExpenses.filter(e => e.category !== 'Uncategorized');
      const total = categorized.reduce((sum, e) => sum + safeAmount(e.amount), 0);
      const uncategorized = validExpenses.length - categorized.length;

      return (
        <div className="container">
          <div style={{marginBottom: '30px'}}>
            <h1 style={{fontSize: '32px', fontWeight: 'bold', marginBottom: '8px'}}>Expense Tracker</h1>
            <p style={{color: '#64748b'}}>Import bank CSVs and categorize expenses</p>
          </div>

          {/* Load Errors */}
          {loadErrors.length > 0 && (
            <div className="error-banner">
              <h3>‚ö†Ô∏è Data Loading Issues</h3>
              {loadErrors.map((err, i) => (
                <p key={i}>{err}</p>
              ))}
              <button className="btn btn-gray" onClick={() => dismissErrors('load')}>
                Dismiss
              </button>
            </div>
          )}

          {/* Import Errors */}
          {importErrors.length > 0 && (
            <div className="error-banner">
              <h3>‚ö†Ô∏è Import Issues</h3>
              {importErrors.slice(0, 5).map((err, i) => (
                <p key={i}>{err}</p>
              ))}
              {importErrors.length > 5 && (
                <p>...and {importErrors.length - 5} more issues</p>
              )}
              <button className="btn btn-gray" onClick={() => dismissErrors('import')}>
                Dismiss
              </button>
            </div>
          )}

          {/* Error Expenses Warning */}
          {errorExpenses.length > 0 && (
            <div className="error-banner">
              <h3>‚ö†Ô∏è {errorExpenses.length} expense(s) have data issues</h3>
              <p>These rows are highlighted in yellow below. You can fix or remove them.</p>
              <button className="btn btn-red" onClick={removeErrorExpenses}>
                Remove All Problem Rows
              </button>
            </div>
          )}

          <div style={{display: 'flex', gap: '10px', marginBottom: '20px', flexWrap: 'wrap'}}>
            <label className="btn btn-blue">
              üì§ Import CSV
              <input type="file" accept=".csv" onChange={handleFileUpload} />
            </label>
            <button className="btn btn-purple" onClick={exportCSV}>üì• Export</button>
            <button className="btn btn-red" onClick={clearAllData}>üóëÔ∏è Clear All</button>
          </div>

          {message && (
            <div style={{padding: '12px', background: '#dbeafe', color: '#1e40af', borderRadius: '8px', marginBottom: '20px'}}>
              {message}
            </div>
          )}

          {uncategorized > 0 && (
            <div style={{padding: '12px', background: '#fef3c7', color: '#92400e', borderRadius: '8px', marginBottom: '20px'}}>
              ‚ö†Ô∏è {uncategorized} transactions need categorization
            </div>
          )}

          <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '20px', marginBottom: '30px'}}>
            <div className="card">
              <div style={{fontSize: '14px', color: '#64748b', marginBottom: '4px'}}>Total</div>
              <div style={{fontSize: '28px', fontWeight: 'bold'}}>{formatAmount(total)}</div>
            </div>
            <div className="card">
              <div style={{fontSize: '14px', color: '#64748b', marginBottom: '4px'}}>Categorized</div>
              <div style={{fontSize: '28px', fontWeight: 'bold'}}>{categorized.length}</div>
            </div>
            <div className="card">
              <div style={{fontSize: '14px', color: '#64748b', marginBottom: '4px'}}>To Review</div>
              <div style={{fontSize: '28px', fontWeight: 'bold'}}>{uncategorized}</div>
            </div>
          </div>

          <div className="card">
            <h2 style={{fontSize: '20px', fontWeight: '600', marginBottom: '20px'}}>Transactions</h2>
            <div style={{overflowX: 'auto'}}>
              <table>
                <thead>
                  <tr>
                    <th>Date</th>
                    <th>Description</th>
                    <th>Account</th>
                    <th>Category</th>
                    <th style={{textAlign: 'right'}}>Amount</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody>
                  {expenses.length === 0 ? (
                    <tr>
                      <td colSpan="6" style={{textAlign: 'center', color: '#64748b', padding: '40px'}}>
                        No expenses yet. Import a CSV to get started.
                      </td>
                    </tr>
                  ) : (
                    [...expenses].sort((a, b) => {
                      // Errors first, then uncategorized
                      if (a.hasError && !b.hasError) return -1;
                      if (!a.hasError && b.hasError) return 1;
                      if (a.category === 'Uncategorized' && b.category !== 'Uncategorized') return -1;
                      if (a.category !== 'Uncategorized' && b.category === 'Uncategorized') return 1;
                      return 0;
                    }).map(exp => (
                      <tr key={exp.id} className={exp.hasError ? 'warning-row' : ''}>
                        <td>
                          {exp.date}
                          {exp.hasError && (
                            <div style={{fontSize: '11px', color: '#991b1b'}}>
                              ‚ö†Ô∏è {exp.errorMsg}
                            </div>
                          )}
                        </td>
                        <td>{exp.description}</td>
                        <td>{exp.account}</td>
                        <td>
                          <select 
                            value={exp.category} 
                            onChange={(e) => updateCategory(exp.id, e.target.value)}
                            style={{
                              background: exp.category === 'Uncategorized' ? '#fee2e2' : '#dbeafe',
                              color: exp.category === 'Uncategorized' ? '#991b1b' : '#1e40af',
                              border: 'none',
                              padding: '4px 8px',
                              borderRadius: '12px',
                              cursor: 'pointer'
                            }}
                          >
                            <option value="Uncategorized">Uncategorized</option>
                            {categories.map(c => <option key={c} value={c}>{c}</option>)}
                          </select>
                        </td>
                        <td style={{textAlign: 'right', fontWeight: '600'}}>{formatAmount(exp.amount)}</td>
                        <td>
                          <button onClick={() => deleteExpense(exp.id)} style={{background: 'none', border: 'none', cursor: 'pointer', fontSize: '18px'}}>
                            üóëÔ∏è
                          </button>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>
          </div>

          <div className={`modal ${showModal ? 'show' : ''}`}>
            <div className="modal-box">
              <h2 style={{fontSize: '22px', fontWeight: 'bold', marginBottom: '16px'}}>Map CSV Columns</h2>
              <p style={{color: '#64748b', marginBottom: '20px'}}>Match columns (Date & Amount required)</p>
              
              <div className="input-group">
                <label>Date *</label>
                <select value={mapping.date} onChange={(e) => setMapping({...mapping, date: e.target.value})}>
                  <option value="">Select...</option>
                  {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                </select>
              </div>

              <div className="input-group">
                <label>Amount *</label>
                <select value={mapping.amount} onChange={(e) => setMapping({...mapping, amount: e.target.value})}>
                  <option value="">Select...</option>
                  {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                </select>
              </div>

              <div className="input-group">
                <label>Description</label>
                <select value={mapping.description} onChange={(e) => setMapping({...mapping, description: e.target.value})}>
                  <option value="">Select...</option>
                  {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                </select>
              </div>

              <div className="input-group">
                <label>Account</label>
                <div className="radio-group">
                  <label>
                    <input 
                      type="radio" 
                      name="accountMode" 
                      checked={accountMode === 'manual'} 
                      onChange={() => setAccountMode('manual')}
                    />
                    Enter name
                  </label>
                  <label>
                    <input 
                      type="radio" 
                      name="accountMode" 
                      checked={accountMode === 'column'} 
                      onChange={() => setAccountMode('column')}
                    />
                    From CSV column
                  </label>
                </div>
                
                {accountMode === 'manual' ? (
                  <input 
                    type="text" 
                    placeholder="e.g., Chase Checking, Amex Gold..." 
                    value={manualAccountName}
                    onChange={(e) => setManualAccountName(e.target.value)}
                  />
                ) : (
                  <select value={mapping.account} onChange={(e) => setMapping({...mapping, account: e.target.value})}>
                    <option value="">Select...</option>
                    {csvHeaders.map(h => <option key={h} value={h}>{h}</option>)}
                  </select>
                )}
              </div>

              <div style={{display: 'flex', gap: '10px', marginTop: '20px'}}>
                <button onClick={processImport} className="btn btn-blue" style={{flex: 1}}>
                  Import {csvData.length} Transactions
                </button>
                <button onClick={() => setShowModal(false)} className="btn btn-gray">Cancel</button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(
      <ErrorBoundary>
        <App />
      </ErrorBoundary>
    );
  </script>
</body>
</html>
